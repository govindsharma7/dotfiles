# .zshrc for Josh Dick <http://joshdick.net>
# Pretty much everything besides the stuff in the "ZSH-SPECIFIC SETTINGS" and "PROMPT FORMATTING" sections should work in bash as well.

# *** MISC ***

# When connecting via ssh, always [re]attach to a terminal manager
# Adapted from code found at <http://involution.com/2004/11/17/1-32/> (now offline)
if [ -f /usr/bin/tmux ] && [ -z $TMUX ]; then
  if [ "$SSH_TTY" != "" -a "$TERM" -a "$TERM" != "screen" -a "$TERM" != "dumb" ]; then
    pgrep tmux
    # $? is the exit code of pgrep; 0 means there was a result (tmux is already running)
    if [ $? -eq 0 ]; then
      tmux -u attach -d
    else
      tmux -u
    fi
  fi
fi

# *** ZSH-SPECIFIC SETTINGS ***

HISTFILE=~/.zsh_history
HISTSIZE=1000
SAVEHIST=1000
setopt autocd beep nomatch prompt_subst correct
unsetopt notify
zstyle :compinstall filename "$HOME/.zshrc"
autoload -Uz compinit && compinit
autoload -U colors && colors # Enable colors in prompt

# Enable Vi keybindings...
bindkey -v
# ...but make alt-. work again. Found in the thread staring at <http://www.zsh.org/mla/users/2004/msg01157.html>
bindkey -M viins '\e.' insert-last-word

# Whle in insert mode, make alt-e trigger an external editor
# More info the thread starting at <http://www.zsh.org/mla/users/2005/msg01301.html>
autoload edit-command-line
zle -N edit-command-line
bindkey -M viins '\ee' edit-command-line

# Make control keys work properly in various terminal emulators
# Found at <https://wiki.archlinux.org/index.php/Zsh>
bindkey "\e[1~" beginning-of-line # Home
bindkey "\e[4~" end-of-line # End
bindkey "\e[5~" beginning-of-history # PageUp
bindkey "\e[6~" end-of-history # PageDown
bindkey "\e[2~" quoted-insert # Ins
bindkey "\e[3~" delete-char # Del
bindkey "\e[5C" forward-word
bindkey "\eOc" emacs-forward-word
bindkey "\e[5D" backward-word
bindkey "\eOd" emacs-backward-word
bindkey "\e\e[C" forward-word
bindkey "\e\e[D" backward-word
bindkey "\e[Z" reverse-menu-complete # Shift+Tab
# for rxvt
bindkey "\e[7~" beginning-of-line # Home
bindkey "\e[8~" end-of-line # End
# for non RH/Debian xterm, can't hurt for RH/Debian xterm
bindkey "\eOH" beginning-of-line
bindkey "\eOF" end-of-line
# for freebsd console
bindkey "\e[H" beginning-of-line
bindkey "\e[F" end-of-line
# for guake
bindkey "\eOF" end-of-line
bindkey "\eOH" beginning-of-line
bindkey "^[[1;5D" backward-word
bindkey "^[[1;5C" forward-word
bindkey "\e[3~" delete-char # Del

precmd () {
  # If z <https://github.com/rupa/z> is available, make sure it captures the current directory
  if `type _z &> /dev/null`; then
    _z --add "$(pwd -P)"
  fi
}

# *** PROMPT FORMATTING ***

PS1="
%(!.%{$fg[red]%}.%{$fg[magenta]%})%n%{$reset_color%}@%{$fg[yellow]%}%m%{$reset_color%}:%{$fg[green]%}%~%u%{$reset_color%}
%{$fg[blue]%}›%{$reset_color%} "

# The following code for manipulating the right-hand prompt is based on code found at <https://gist.github.com/1712320>

GIT_PROMPT_PREFIX="%{$fg[green]%}[%{$reset_color%}"
GIT_PROMPT_SUFFIX="%{$fg[green]%}]%{$reset_color%}"
GIT_PROMPT_AHEAD="%{$fg[red]%}ANUM%{$reset_color%}"
GIT_PROMPT_BEHIND="%{$fg[cyan]%}BNUM%{$reset_color%}"
GIT_PROMPT_MERGING="%{$fg_bold[magenta]%}⚡%{$reset_color%}"
GIT_PROMPT_UNTRACKED="%{$fg_bold[red]%}●%{$reset_color%}"
GIT_PROMPT_MODIFIED="%{$fg_bold[yellow]%}●%{$reset_color%}"
GIT_PROMPT_STAGED="%{$fg_bold[green]%}●%{$reset_color%}"

# Show git branch/tag, or name-rev if on detached head
parse_git_branch() {
  (git symbolic-ref -q HEAD || git name-rev --name-only --no-undefined --always HEAD) 2> /dev/null
}

# Show different symbols as appropriate for various git repository states
parse_git_state() {

  local GIT_STATE=""

  local NUM_AHEAD="$(git log --oneline @{u}.. 2> /dev/null | wc -l | tr -d ' ')"
  if [ "$NUM_AHEAD" -gt 0 ]; then
    GIT_STATE=$GIT_STATE${GIT_PROMPT_AHEAD//NUM/$NUM_AHEAD}
  fi

  local NUM_BEHIND="$(git log --oneline ..@{u} 2> /dev/null | wc -l | tr -d ' ')"
  if [ "$NUM_BEHIND" -gt 0 ]; then
    GIT_STATE=$GIT_STATE${GIT_PROMPT_BEHIND//NUM/$NUM_BEHIND}
  fi

  local GIT_DIR="$(git rev-parse --git-dir 2> /dev/null)"
  if [ -n $GIT_DIR ] && test -r $GIT_DIR/MERGE_HEAD; then
    GIT_STATE=$GIT_STATE$GIT_PROMPT_MERGING
  fi

  if [[ -n $(git ls-files --other --exclude-standard 2> /dev/null) ]]; then
    GIT_STATE=$GIT_STATE$GIT_PROMPT_UNTRACKED
  fi

  if ! git diff --quiet 2> /dev/null; then
    GIT_STATE=$GIT_STATE$GIT_PROMPT_MODIFIED
  fi

  if ! git diff --cached --quiet 2> /dev/null; then
    GIT_STATE=$GIT_STATE$GIT_PROMPT_STAGED
  fi

  if [[ -n $GIT_STATE ]]; then
    echo "$GIT_PROMPT_PREFIX$GIT_STATE$GIT_PROMPT_SUFFIX"
  fi

}

# If inside a git repository, show its state and branch
git_custom_status() {
  local git_where="$(parse_git_branch)"
  [ -n "$git_where" ] && echo "%{$fg[blue]%}±$(parse_git_state)$GIT_PROMPT_PREFIX%{$fg[yellow]%}${git_where#(refs/heads/|tags/)}$GIT_PROMPT_SUFFIX"
}

# Set the right-hand prompt
RPS1='$(git_custom_status)'

# *** FUNCTIONS ***

# Test whether a given command exists
# Adapted from http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script/3931779#3931779
command_exists() {
  hash "$1" &> /dev/null
}

# To search for a given string inside every file with the given filename
# (wildcards allowed) in the current directory, recursively:
#   $ searchin filename pattern
#
# To search for a given string inside every file inside the current directory, recursively:
#   $ searchin pattern
searchin() {
  if [ -n "$2" ]; then
    find . -name "$1" -type f -exec grep -l "$2" {} \;
  else
    find . -type f -exec grep -l "$1" {} \;
  fi
}

# Performs a system update on Debian-based and Arch Linux systems, updates Homebrew packages on OS X, updates all Git submodules
update() {
  if command_exists apt-get; then
    echo "Updating packages via apt-get..."
    sudo apt-get update
    sudo apt-get upgrade
  elif command_exists pacman; then
    echo "Upadting packages via pacman..."
    sudo pacman -Syu
  fi

  # If the the home directory was symlinked out of a Git repo, update it and all submodules
  if test -h ~/.zshrc && command_exists git; then
    local DOTFILES_REPO_LOCATION=${$(readlink ~/.zshrc)%/*.*}
    pushd -q
    cd $DOTFILES_REPO_LOCATION
    echo "Updating dotfiles..."
    git pull
    echo "Updating git submodules..."
    # Adapted from code found at <http://stackoverflow.com/questions/1030169/git-easy-way-pull-latest-of-all-submodules>
    git submodule foreach 'git checkout master &> /dev/null; git checkout . &> /dev/null; git pull origin master'
    popd -q
  fi

  if command_exists brew; then
    echo "Updating/upgrading/cleaning up Homebrew packages..."
    brew update && brew upgrade && brew cleanup && brew linkapps
  fi
}

# Pushes local SSH public key to another box
# Adapted from code found at <https://github.com/rtomayko/dotfiles/blob/rtomayko/.bashrc>
push_ssh_cert() {
    if [[ $# -eq 0 || $# -gt 3 ]]; then
      echo "Usage: push_ssh_cert host [port] [username]"
      return
    fi
    local _host=$1
    local _port=22
    local _user=$USER
    if [[ $# -ge 2 ]]; then
      _port=$2
    fi
    if [[ $# -eq 3 ]]; then
      _user=$3
    fi
    test -f ~/.ssh/id_dsa.pub || ssh-keygen -t dsa
    echo "Pushing public key to $_user@$_host:$_port..."
    ssh -p $_port $_user@$_host 'mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys' < ~/.ssh/id_*sa.pub
}

# Extracts archives
# Found at <http://pastebin.com/CTra4QTF>
function extract() {
  case $@ in
    *.tar.bz2) tar -xvjf "$@"  ;;
    *.tar.gz)  tar -xvzf "$@"  ;;
    *.bz2)     bunzip2 "$@"  ;;
    *.rar)     unrar x "$@"  ;;
    *.gz)      gunzip "$@" ;;
    *.tar)     tar xf "$@" ;;
    *.tbz2)    tar -xvjf "$@"  ;;
    *.tgz)     tar -xvzf "$@"  ;;
    *.zip)     unzip "$@"    ;;
    *.xpi)     unzip "$@"    ;;
    *.Z)       uncompress "$@" ;;
    *.7z)      7z x "$@" ;;
    *.ace)     unace e "$@"  ;;
    *.arj)     arj -y e "$@" ;;
    *)         echo "'$@' cannot be extracted via $0()" ;;
  esac
}

# Packs $2-$n into $1 depending on $1's extension
# Found at <http://pastebin.com/CTra4QTF>
function compress() {
  if [ $# -lt 2 ] ; then
    echo -e "\n$0() usage:"
    echo -e "\t$0 archive_file_name file1 file2 ... fileN"
    echo -e "\tcreates archive of files 1-N\n"
  else
    DEST=$1
    shift
    case $DEST in
      *.tar.bz2) tar -cvjf $DEST "$@" ;;
      *.tar.gz)  tar -cvzf $DEST "$@" ;;
      *.zip)     zip -r $DEST "$@" ;;
      *)         echo "Unknown file type - $DEST" ;;
    esac
  fi
}

# Poor-man's pgrep, for use on OS X where pgrep isn't available
function psgrep() {
  echo "Warning: using poor-man's pgrep. Consider installing the 'proctools' package via Homebrew."
  ps ax | awk "/(^|[^)])$1/ { print \$1 }"
}

# mkdir and cd into it - supports hierarchies and spaces
# Found at <http://onethingwell.org/post/586977440/mkcd-improved>
function mkcd() {
  mkdir -p "$*"
  cd "$*"
}

# Show uesful information about domain names using dig.
# Found at <https://github.com/mathiasbynens/dotfiles/blob/master/.functions>
function digit() {
  dig +nocmd "$1" any +multiline +noall +answer
}

# *** ALIASES ***

# Awesome platform-independent ls formatting
# Adapted from code found at <http://www.reddit.com/r/linux/comments/hejra/til_nifty_ls_option_for_displaying_directories/c1utfxb>
GLS_ARGS="--classify --tabsize=0 --literal --color=auto --show-control-chars --human-readable --group-directories-first"
alias ls="ls $GLS_ARGS"
ls &> /dev/null
if [ $? -eq 1 ]; then # The environment ls isn't GNU ls; we're not on Linux
  # On OS X, use gls if it has been installed via Homebrew
  if command_exists gls; then
    alias ls="gls $GLS_ARGS"
  else
    alias ls='ls -G' # If not, fall back to BSD ls
  fi
fi

alias lsd='ls -lah | grep "^d"'
alias grep='grep --color'
alias hgrep='history 1 | grep $1'
alias search='find . -name'
alias scpresume='rsync --partial --progress --rsh=ssh'
alias servedir='python -m SimpleHTTPServer $1'
alias mirror='wget -H -r --level=1 -k -p $1'

alias g='git'
alias gc='git commit'
alias gco='git checkout'
alias gd='git diff'
alias gdc='git diff --cached'
alias gl='git log'
alias glo='git log --oneline'
alias gm='git merge'
alias gmf='git merge --ff'
alias gs='git status'
alias gclean='find . -name ".git" -type d -exec echo "Cleaning {}..." ; -exec git --git-dir="{}" gc --aggressive --quiet \;'

# *** ENVIRONMENT ***

# Editor - See if vim lives around these parts, otherwise fall back to nano
if command_exists vim; then
  export EDITOR=vim
  export VISUAL=vim
else
  export EDITOR=nano
  export VISUAL=nano
fi

# Prevent Git from prompting for merge commit messages (as of Git 1.7.10)
export GIT_MERGE_AUTOEDIT=no

# Emulate pgrep if we're on OS X
if ! command_exists pgrep; then
  alias pgrep=psgrep
fi

# Use the most pager if it's available <http://www.jedsoft.org/most>
if command_exists most; then
  export PAGER=most
fi

# LSCOLORS - Default except for normal directories (first character) to replace hard-to-read blue
# For details, see manpage for ls
export LSCOLORS=Gxfxcxdxbxegedabagacad

# Clear out and reset PATH in case .zshrc is sourced multiple times in one session (while making changes)
export PATH=
. /etc/profile

# If we're on OS X and using Homebrew package manager, add Homebrew binary directory to PATH
if command_exists brew; then
  export PATH=`brew --prefix`/bin:`brew --prefix`/sbin:$PATH

  # While we're here, set up completion for Git if it's available via the Homebrew bash-completion package.
  # ZSH's built-in Git completion doesn't complete filenames for some reason, so use bash's instead.
  GIT_BASH_COMPLETION=`brew --prefix`/etc/bash_completion.d/git-completion.bash
  test -r $GIT_BASH_COMPLETION && . $GIT_BASH_COMPLETION

  # If Python 2 was installed via Homebrew, add it to PATH
  PYTHON2_DIR="/usr/local/share/python"
  test -d $PYTHON2_DIR && export PATH=$PYTHON2_DIR:$PATH
fi

# If npm's global node_modules directory exists in the expected location, set NODE_PATH accordingly
NODE_MODULE_PATH="/usr/local/lib/node_modules"
test -d $NODE_MODULE_PATH && export NODE_PATH=$NODE_MODULE_PATH

# Initialize RVM if it's installed
[[ -s $HOME/.rvm/scripts/rvm ]] && source $HOME/.rvm/scripts/rvm

# Initialize the "personal bin"
test -r ~/.bin/bin_init.zsh && . ~/.bin/bin_init.zsh

# Include any machine-specific configuration if it exists
test -r ~/.localrc && . ~/.localrc
