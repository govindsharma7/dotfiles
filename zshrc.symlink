# .zshrc for Josh Dick <http://joshdick.net>

# *** MISC ***

# When connecting via ssh, always [re]attach to a terminal manager
# Adapted from code found at <http://involution.com/2004/11/17/1-32/> (now offline)
if [ -f /usr/bin/tmux ] && [ -z $TMUX ]; then
  if [ "$SSH_TTY" != "" -a "$TERM" -a "$TERM" != "screen" -a "$TERM" != "dumb" ]; then
    pgrep tmux
    # $? is the exit code of pgrep; 0 means there was a result (tmux is already running)
    if [ $? -eq 0 ]; then
      tmux -u attach -d
    else
      tmux -u
    fi
  fi
fi

# Clear out and reset PATH in case .zshrc is sourced multiple times in one session (while making changes)
# Do this before anything else so that this file can override any default settings that may be in /etc/profile
export PATH=
. /etc/profile

# Test whether a given command exists
# Adapted from http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script/3931779#3931779
function command_exists() {
  hash "$1" &> /dev/null
}

# Include any machine-specific configuration if it exists
test -r ~/.localrc && . ~/.localrc

# *** ZSH-SPECIFIC SETTINGS ***

HISTFILE=~/.zsh_history
HISTSIZE=1000
SAVEHIST=1000
setopt autocd beep nomatch prompt_subst correct inc_append_history share_history
unsetopt notify
zstyle :compinstall filename "$HOME/.zshrc"
autoload -Uz compinit && compinit
autoload -U colors && colors # Enable colors in prompt

# *** ZSH KEYBOARD SETTINGS ***

bindkey "^[[H" beginning-of-line
bindkey "^[[1~" beginning-of-line
bindkey "^[[7~" beginning-of-line
bindkey "^[[F" end-of-line
bindkey "^[[4~" end-of-line
bindkey "^[[8~" end-of-line
bindkey "^[[3~" delete-char
bindkey "^[[1;2C" forward-word
bindkey "^[[1;2D" backward-word

# *** PROMPT FORMATTING ***

# Echoes a username/host string when connected over SSH (empty otherwise)
ssh_info() {
  [[ "$SSH_CONNECTION" != '' ]] && echo '%(!.%{$fg[red]%}.%{$fg[yellow]%})%n%{$reset_color%}@%{$fg[green]%}%m%{$reset_color%}:' || echo ''
}

# Use ❯ as the non-root prompt character; # for root
# Change the prompt character color if the last command had a nonzero exit code
PS1="
$(ssh_info)%{$fg[magenta]%}%~%u%{$reset_color%}
%(?.%{$fg[blue]%}.%{$fg[red]%})%(!.#.❯)%{$reset_color%} "

# Right-hand Git prompt <https://gist.github.com/4415470>
. ~/.zsh/git-prompt/git_prompt.zsh

# *** ZSH PLUGINS ***

# <https://github.com/zsh-users/zsh-syntax-highlighting>
. ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# <https://github.com/zsh-users/zsh-history-substring-search>
. ~/.zsh/zsh-history-substring-search/zsh-history-substring-search.zsh

# Bind up and down keys for zsh-history-substring-search
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down

# <https://github.com/junegunn/fzf>
. ~/.fzf.zsh

# *** FUNCTIONS AND ALIASES ***

. ~/.zsh/functions.zsh
. ~/.zsh/aliases.zsh

# *** ENVIRONMENT ***

# Editor - See if vim lives around these parts, otherwise fall back to nano
if command_exists vim; then
  export EDITOR=vim
  export VISUAL=vim
else
  export EDITOR=nano
  export VISUAL=nano
fi

export PAGER=less
export GIT_PAGER="emojify | less -rX"

# Emulate pgrep if we're on OS X
if ! command_exists pgrep; then
  alias pgrep=poorgrep
fi

# Emulate tree if we're on OS X
if ! command_exists tree; then
  alias tree=poortree
fi

# LSCOLORS - Default except for normal directories (first character) to replace hard-to-read blue
# For details, see manpage for ls
export LSCOLORS=Gxfxcxdxbxegedabagacad

# Locations of the Git completion files in Arch Linux as of Git 1.8.1
GIT_BASH_COMPLETION_SOURCE=/usr/share/git/completion/git-completion.bash
GIT_ZSH_COMPLETION_SOURCE=/usr/share/git/completion/git-completion.zsh

# If we're on OS X and using Homebrew package manager, do some Homebrew-specific environmental tweaks
if command_exists brew; then
  export PATH=`brew --prefix`/bin:`brew --prefix`/sbin:$PATH

  # Assume Git was installed via Homebrew, and that the Git completion setup below
  # should use Homebrew-provided completion files instead of the Arch Linux defaults above
  GIT_BASH_COMPLETION_SOURCE=`brew --prefix`/etc/bash_completion.d/git-completion.bash
  GIT_ZSH_COMPLETION_SOURCE=`brew --prefix`/share/zsh/site-functions/_git

  # Homebrew-provided npm
  BREW_NPM_BINARY_DIR=`brew --prefix`/share/npm/bin
  test -d $BREW_NPM_BINARY_DIR && export PATH=$BREW_NPM_BINARY_DIR:$PATH
fi

# Attempt to set up Git completion for zsh as documented inside git-completion.zsh
if [ -r "$GIT_BASH_COMPLETION_SOURCE" ] && [ -r "$GIT_ZSH_COMPLETION_SOURCE" ]; then
  zstyle ':completion:*:*:git:*' script $GIT_BASH_COMPLETION_SOURCE
  # If it doesn't already exist, create a symlink to the zsh completion file as ~/.zsh/completion/_git.
  # If the file was copied via sync_home and isn't actually a symlink, it will be replaced with a symlink.
  [ ! -h ~/.zsh/completion/_git ] && mkdir -p ~/.zsh/completion && rm -f ~/.zsh/completion/_git && ln -s $GIT_ZSH_COMPLETION_SOURCE ~/.zsh/completion/_git
  # Add the ~/.zsh/completion directory to fpath so zsh can find it.
  fpath=(~/.zsh/completion $fpath)
fi

NVM_DIR="$HOME/.nvm"
HOMEBREW_NODE_MODULE_DIR="/usr/local/lib/node_modules"
if [ -s "$NVM_DIR/nvm.sh" ]; then
  # Initialize nvm if it's installed
  . "$NVM_DIR/nvm.sh"
elif [ -d $HOMEBREW_NODE_MODULE_DIR ]; then
  # If node was installed via Homebrew, set NODE_PATH accordingly
  export NODE_PATH=$HOMEBREW_NODE_MODULE_DIR
fi

# Initialize rbenv if it's installed (it may be installed via Homebrew)
RBENV_BIN_DIR="$HOME/.rbenv/bin"
test -d $RBENV_BIN_DIR && export PATH="$RBENV_BIN_DIR:$PATH"
if command_exists rbenv; then
  eval "$(rbenv init -)";
fi

# Initialize a default Python virtualenv if one is configured in ~/.localrc
# (VIRTUALENV_ACTIVATOR should point to ./bin/activate)
if [ -n "$VIRTUALENV_ACTIVATOR" -a -r "$VIRTUALENV_ACTIVATOR" ]; then
  VIRTUAL_ENV_DISABLE_PROMPT=1 . "$VIRTUALENV_ACTIVATOR"
fi

# Initialize the "personal bin"
. ~/.bin/bin_init.zsh
