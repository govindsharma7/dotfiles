# .zshrc for Josh Dick <http://joshdick.net>

# *** MISC ***

# When connecting via ssh, always [re]attach to a terminal manager
# Adapted from code found at <http://involution.com/2004/11/17/1-32/> (now offline)
if [ -f /usr/bin/tmux ] && [ -z $TMUX ]; then
  if [ "$SSH_TTY" != "" -a "$TERM" -a "$TERM" != "screen" -a "$TERM" != "dumb" ]; then
    pgrep tmux
    # $? is the exit code of pgrep; 0 means there was a result (tmux is already running)
    if [ $? -eq 0 ]; then
      tmux -u attach -d
    else
      tmux -u
    fi
  fi
fi

# Clear out and reset PATH in case .zshrc is sourced multiple times in one session (while making changes)
# Do this before anything else so that this file can override any default settings that may be in /etc/profile
export PATH=
. /etc/profile

# Test whether a given command exists
# Adapted from http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script/3931779#3931779
function command_exists() {
  hash "$1" &> /dev/null
}

# *** ZSH-SPECIFIC SETTINGS ***

HISTFILE=~/.zsh_history
HISTSIZE=1000
SAVEHIST=1000
setopt autocd beep nomatch prompt_subst correct
unsetopt notify
zstyle :compinstall filename "$HOME/.zshrc"
autoload -Uz compinit && compinit
autoload -U colors && colors # Enable colors in prompt

# *** ZSH KEYBOARD SETTINGS ***

# This configuration was found at http://zshwiki.org/home/zle/bindkeys

# Create a zkbd compatible hash;
# to add other keys to this hash, see: man 5 terminfo
typeset -A key

key[Home]=${terminfo[khome]}
key[End]=${terminfo[kend]}
key[Insert]=${terminfo[kich1]}
key[Delete]=${terminfo[kdch1]}
key[Up]=${terminfo[kcuu1]}
key[Down]=${terminfo[kcud1]}
key[Left]=${terminfo[kcub1]}
key[Right]=${terminfo[kcuf1]}
key[PageUp]=${terminfo[kpp]}
key[PageDown]=${terminfo[knp]}

# Set up keys accordingly.
[[ -n "${key[Home]}"    ]]  && bindkey  "${key[Home]}"    beginning-of-line
[[ -n "${key[End]}"     ]]  && bindkey  "${key[End]}"     end-of-line
[[ -n "${key[Insert]}"  ]]  && bindkey  "${key[Insert]}"  overwrite-mode
[[ -n "${key[Delete]}"  ]]  && bindkey  "${key[Delete]}"  delete-char
[[ -n "${key[Up]}"      ]]  && bindkey  "${key[Up]}"      up-line-or-history
[[ -n "${key[Down]}"    ]]  && bindkey  "${key[Down]}"    down-line-or-history
[[ -n "${key[Left]}"    ]]  && bindkey  "${key[Left]}"    backward-char
[[ -n "${key[Right]}"   ]]  && bindkey  "${key[Right]}"   forward-char

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
function zle-line-init () {
    echoti smkx
}
function zle-line-finish () {
    echoti rmkx
}
zle -N zle-line-init
zle -N zle-line-finish

# *** COLOR SCHEME ***

# Needed for base16-vim color scheme to work properly.
# Using the "tomorrow" variant for vim while using the "bright"
# variant for the shell seems to work fine.
. ~/.zsh/base16-shell/base16-bright.dark.sh

# *** PROMPT FORMATTING ***

PS1="
%(!.%{$fg[red]%}.%{$fg[magenta]%})%n%{$reset_color%}@%{$fg[yellow]%}%m%{$reset_color%}:%{$fg[green]%}%~%u%{$reset_color%}
%{$fg[blue]%}â€º%{$reset_color%} "

# Right-hand Git prompt <https://gist.github.com/4415470>
. ~/.zsh/git-prompt/git_prompt.zsh

# *** ZSH PLUGINS ***

# <https://github.com/zsh-users/zsh-syntax-highlighting>
. ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# <https://github.com/zsh-users/zsh-history-substring-search>
. ~/.zsh/zsh-history-substring-search/zsh-history-substring-search.zsh

# <https://github.com/junegunn/fzf>
. ~/.fzf.zsh

# Bind up and down keys for zsh-history-substring-search
for keycode in '[' '0'; do
  bindkey "^[${keycode}A" history-substring-search-up
  bindkey "^[${keycode}B" history-substring-search-down
done
unset keycode

# *** FUNCTIONS AND ALIASES ***

. ~/.zsh/functions.zsh
. ~/.zsh/aliases.zsh

# *** ENVIRONMENT ***

# Editor - See if vim lives around these parts, otherwise fall back to nano
if command_exists vim; then
  export EDITOR=vim
  export VISUAL=vim
else
  export EDITOR=nano
  export VISUAL=nano
fi

# Emulate pgrep if we're on OS X
if ! command_exists pgrep; then
  alias pgrep=poorgrep
fi

# Emulate tree if we're on OS X
if ! command_exists tree; then
  alias tree=poortree
fi

# Use the most pager if it's available <http://www.jedsoft.org/most>
if command_exists most; then
  export PAGER=most
fi

# LSCOLORS - Default except for normal directories (first character) to replace hard-to-read blue
# For details, see manpage for ls
export LSCOLORS=Gxfxcxdxbxegedabagacad

# Locations of the Git completion files in Arch Linux as of Git 1.8.1
GIT_BASH_COMPLETION_SOURCE=/usr/share/git/completion/git-completion.bash
GIT_ZSH_COMPLETION_SOURCE=/usr/share/git/completion/git-completion.zsh

# If we're on OS X and using Homebrew package manager, do some Homebrew-specific environmental tweaks
if command_exists brew; then
  export PATH=`brew --prefix`/bin:`brew --prefix`/sbin:$PATH

  # Assume Git was installed via Homebrew, and that the Git completion setup below
  # should use Homebrew-provided completion files instead of the Arch Linux defaults above
  GIT_BASH_COMPLETION_SOURCE=`brew --prefix`/etc/bash_completion.d/git-completion.bash
  GIT_ZSH_COMPLETION_SOURCE=`brew --prefix`/share/zsh/site-functions/_git

  BREW_NPM_BINARY_DIR="/usr/local/share/npm/bin"
  test -d $BREW_NPM_BINARY_DIR && export PATH=$BREW_NPM_BINARY_DIR:$PATH
fi

# Attempt to set up Git completion for zsh as documented inside git-completion.zsh
if [ -r "$GIT_BASH_COMPLETION_SOURCE" ] && [ -r "$GIT_ZSH_COMPLETION_SOURCE" ]; then
  zstyle ':completion:*:*:git:*' script $GIT_BASH_COMPLETION_SOURCE
  # If it doesn't already exist, create a symlink to the zsh completion file as ~/.zsh/completion/_git.
  # If the file was copied via sync_home and isn't actually a symlink, it will be replaced with a symlink.
  [ ! -h ~/.zsh/completion/_git ] && mkdir -p ~/.zsh/completion && rm -f ~/.zsh/completion/_git && ln -s $GIT_ZSH_COMPLETION_SOURCE ~/.zsh/completion/_git
  # Add the ~/.zsh/completion directory to fpath so zsh can find it.
  fpath=(~/.zsh/completion $fpath)
fi

# If npm's global node_modules directory exists in the expected location, set NODE_PATH accordingly
NODE_MODULE_DIR="/usr/local/lib/node_modules"
test -d $NODE_MODULE_DIR && export NODE_PATH=$NODE_MODULE_DIR

# Initialize rbenv if it's installed
RBENV_BIN_DIR="$HOME/.rbenv/bin"
if [ -d $RBENV_BIN_DIR ]; then
  export PATH="$RBENV_BIN_DIR:$PATH"
  eval "$(rbenv init -)"
fi

# Initialize the "personal bin"
. ~/.bin/bin_init.zsh

# Include any machine-specific configuration if it exists
test -r ~/.localrc && . ~/.localrc
